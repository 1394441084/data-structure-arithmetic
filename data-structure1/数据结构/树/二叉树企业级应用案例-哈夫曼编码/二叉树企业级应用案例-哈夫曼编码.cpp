#include "二叉树企业级应用案例-哈夫曼编码.h"

/*
哈夫曼编码 
哈夫曼（Huffman）编码算法是基于二叉树构建编码压缩结构的，它是数据压缩中经典的一种算 法。
算法根据文本字符出现的频率，重新对字符进行编码。 首先请大家阅读下面两段中外小学作文： 

中国 - 今天天气晴朗，我和小明出去玩！小明贪玩，不小心摔了一跤，小明被摔得哇哇哭了，小明的爸爸闻 声赶来，又把小明痛扁了一阵。
小明的小屁屁都被揍扁了，因为小明把妈妈刚买给他的裤子弄破了！ 

外国 - 今天天气晴朗，我和乔伊・亚历山大・比基・卡利斯勒・达夫・埃利奥特・福克斯・伊维鲁莫・马尔 尼・梅尔斯・帕特森・汤普森・华莱士・普雷斯顿出去玩！
乔伊・亚历山大・比基・卡利斯勒・达夫・埃利奥 特・福克斯・伊维鲁莫・马尔尼・梅尔斯・帕特森・汤普森・华莱士・普雷斯顿贪玩，
不小心摔了一跤，乔伊・亚 历山大・比基・卡利斯勒・达夫・埃利奥特・福克斯・伊维鲁莫・马尔尼・梅尔斯・帕特森・汤普森・华莱士・普雷斯顿被摔得哇哇哭了，
乔伊・亚历山大・比基・卡利斯勒・达夫・埃利奥特・福克斯・伊维鲁莫・马尔尼・梅 尔斯・帕特森・汤普森・华莱士・普雷斯顿的爸爸闻声赶来，
又把乔伊・亚历山大・比基・卡利斯勒・达夫・埃 利奥特・福克斯・伊维鲁莫・马尔尼・梅尔斯・帕特森・汤普森・华莱士・普雷斯顿痛扁了一阵。
乔伊・亚历 山大・比基・卡利斯勒・达夫・埃利奥特・福克斯・伊维鲁莫・马尔尼・梅尔斯・帕特森・汤普森・华莱士・普 雷斯顿的小屁屁都被揍扁了，
因为乔伊・亚历山大・比基・卡利斯勒・达夫・埃利奥特・福克斯・伊维鲁莫・马 尔尼・梅尔斯・帕特森・汤普森・华莱士・普雷斯顿把妈妈刚买给他的裤子弄破了！

 同一段内容，当小明换成了外国小朋友的名字，篇幅就增加了几倍，有没有办法把内容缩减呢？
 当然有！在文章的开头，先声明一个缩写： 
 名字 缩写 乔伊・亚历山大・比基・卡利斯勒・达夫・埃利奥特・福克斯・伊维鲁莫・马尔尼・梅 尔斯・帕特森・汤普森・华莱士・普雷斯顿 乔顿 那么，
 上面这段文字就可以缩成很小的一段： 今天天气晴朗，我和乔顿出去玩！乔顿贪玩，不小心摔了一跤，乔顿被摔得哇哇哭了，乔顿的爸爸闻声赶来，
 又把小明痛扁了一阵。乔顿的小屁屁都被揍扁了，因为乔顿把妈妈刚买给他的裤子弄破了！

 哈夫曼编码就是这样一个原理！按照文本字符出现的频率，出现次数越多的字符用越简短的编码 替代，因为为了缩短编码的长度，我们自然希望频率越高的词，
 编码越短，这样最终才能最大化 压缩存储文本数据的空间。 哈夫曼编码举例：
 
 假设要对“we will we will r u”进行压缩。 
 压缩前,使用 ASCII 码保存: 119 101 32 119 105 108 108 32 119 101 32 119 105 108 108 32 114 32 117 
 共需： 19 个字节 - 152 个位保存

下面我们先来统计这句话中每个字符出现的频率。
如下表，按89频79率43高8低40已1排11序1：
	字符 		空格  w l e i r u 
		权重或频率 5  4 4 2 2 1 1  
		
接下来，我们按照字符出现的频率，制定如下的编码表： 
	字符  l  w 空格   e    i     u     r 
	编码 00 01 10   110 1111 11100 11101 
	这样，“we will we will r u”就可以按如下的位来保存： 
	01 110 10 01 1111 00 00 10 01 110 10 01 1111 00 00 10 11101 10 11100
	
	哈夫曼二叉树构建 
	1. 按出现频率高低将其放入一个数组中，从左到右依次为频率逐渐增加;
	2. 从左到右进行合并，依次构建二叉树。第一步取前两个字符 u 和 r 来构造初始二叉树，
	   第一个 字符作为左节点，第二个元素作为右节点，然后两个元素相加作为新的空元素，
	   并且两者权重相 加作为新元素的权重。
	3. 新节点加入后，依据权重重新排序，按照权重从小到大排列。 
	4. 红色区域的新增元素可以继续和 i 合并
*/

void PreOrderRec(Btree* root); /* 构造哈夫曼编码树 */ 
void HuffmanTree(Btree*& huff, int n) {
	LinkQueue* LQ = new LinkQueue;
	int i = 0;
	//初始化队列 
	InitQueue(LQ);
	/* 初始化存放哈夫曼树数组 HuffNode[] 中的结点 */
	for (i = 0; i < n; i++) {
		Bnode* node = new Bnode;
		cout << "请输入第" << i + 1 << "个字符和出现频率: " << endl;
		cin >> node->value; //输入字符 
		cin >> node->weight;//输入权值
		node->parent = NULL;
		node->lchild = NULL;
		node->rchild = NULL;
		EnterQueue(LQ, node, node->weight);
	}
	PrintQueue(LQ);
	//system("pause");
	//exit(0); 
	do {
		Bnode* node1 = NULL;
		Bnode* node2 = NULL;
		if (!IsEmpty(LQ)) {
			PopQueue(LQ, &node1);
			printf("第一个出队列的数：%c, 优先级: %d\n", node1->value, node1->weight);
		}
		else {
			break;
		}
		if (!IsEmpty(LQ)) {
			Bnode* node3 = new Bnode;
			PopQueue(LQ, &node2);
			printf("第二个出队列的数：%c, 优先级: %d\n", node2->value, node2->weight);
			node3->lchild = node1;
			node1->parent = node3;
			node3->rchild = node2;
			node2->parent = node3;
			node3->value = ' ';
			node3->weight = node1->weight + node2->weight;
			printf("合并进队列的数：%c, 优先级: %d\n", node3->value, node3->weight);
			EnterQueue(LQ, node3, node3->weight);
		}
		else {
			huff = node1;
			break;
		}
	} while (1);
}

/************************ * 采用递归方式实现前序遍历 *************************/
void PreOrderRec(Btree* root) {
	if (root == NULL) {
		return;
	}
	printf("- %c -", root->value);
	PreOrderRec(root->lchild);
	PreOrderRec(root->rchild);
}

int main(void) {
	Btree* tree = NULL;
	HuffmanTree(tree, 7);
	PreOrderRec(tree);
	system("pause");
	return 0;
}